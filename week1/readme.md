# Rustè®€æ›¸æœƒ Week 1

# CH1~CH2 
é‚„æ˜¯ç¨å¾®è¬›ä¸€ä¸‹å¥½æƒ¹

## Hello Rust
```rust=
//hello.rs
fn main(){
    println!("hello rust")
}
```
* Compile & run (Windows) 
> rustc hello.rs
> ./hello.exe

* Compileå¾Œæœƒç”¢ç”Ÿå…©å€‹æª”æ¡ˆ
  * exe
  * pdb
    * debug info 
> ls
> main.exe
> main.pdb
> main.rs

* ahead-of-time compiled language
  * æŒ‡çš„æ˜¯å¯ä»¥æŠŠ.exeçµ¦åˆ¥äººç›´æ¥åŸ·è¡Œçš„èªè¨€ï¼Œä½†è‹¥æ˜¯Ruby,Pythonä¹‹é¡çš„å°±ä¸è¡Œï¼Œå¾—ç”¨PyInstallerä¹‹é¡çš„é¡å¤–åŒ…èµ·ä¾† 

## Cargo
Rustçš„ç¨‹å¼ç¢¼å°ˆæ¡ˆç®¡ç†å’Œå»ºç½®å·¥å…·

* å»ºç«‹Cargo project
> cargo new å°ˆæ¡ˆåç¨±


* Project list
![](https://i.imgur.com/hopFGFP.jpg)

* Cargo.toml
  *  TOML (Tomâ€™s Obvious, Minimal Language) format
  *  å…¶å¯¦å°±æ˜¯ä¸€ç¨®configuration file format
```
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2018"

[dependencies]
```
* Cargo.lock
  * å°±è¨˜éŒ„ä¸€äº›é€™å€‹projectç”¨åˆ°çš„dependenciesçš„versionï¼Œé¡ä¼¼go mod 
```
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
[[package]]
name = "hello_cargo"
version = "0.1.0"
```

* Run & Build in Cargo
  * runä¹‹å‰æ²’æœ‰å…ˆbuildçš„è©±æœƒå…ˆå¹«ä½ buildå†run 
> cargo run
> cargo build

* cargo check
å¯ä»¥ç”¨ä¾†å¿«é€Ÿæª¢é©—æ˜¯å¦å¯ä»¥é€šécompile

* cargo update
åªæœƒupdate **Cargo.lock**ä¸­çš„æ±è¥¿

* cargo test
test

* Delete cargo
æœƒæŠŠtargetç›®éŒ„ä¸‹çš„æ±è¥¿å…¨éƒ¨åˆªé™¤
> cargo clean

* å®‰è£å¥—ä»¶ï¼Œä»¥randèˆ‰ä¾‹
[doc](https://crates.io/crates/rand)

1. ç›´æ¥ä¿®æ”¹toml
![](https://i.imgur.com/LbLTYQg.jpg)

2. ç”¨cargo-edit
> cargo install cargo-edit
> cargo add rand

## Guessing number game
[thread-rng doc](https://docs.rs/rand/0.6.5/rand/fn.thread_rng.html)

```rust=
// Rngæ˜¯randçš„trait, å®šç¾©äº†gen_rangeçš„å¯¦ä½œ, ç”¨ä¾†æ“´å……thread_rng // ch10æœƒè«‡åˆ°trait
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");
    // rustç”¨::ä¾†å°‹æ‰¾æŒ‡å®šå¥—ä»¶ä¸‹çš„func
    let secret_number = rand::thread_rng().gen_range(1, 101);
	// loop = infinite loop, å¦å¤–Rustæœ‰while, forå¯ç”¨
    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        // å‘¼å«stdinå’Œread_line method
        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");
	// trim space
		
	// parseæ˜¯å°‡string -> unsigned int 32
	// å…©å€‹è®Šæ•¸åç¨±ä¸€æ¨£, æ–°çš„guessåœ¨å®£å‘Šä¹‹å¾Œæœƒshadowæ‰åŸæœ¬çš„guess
	// å³é‚Šçš„guessæ˜¯å‰›å‰›å®£å‘Šé‚£å€‹
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);
        // ch6, ch18æœƒè«‡æ›´å¤šmatch, å¯ä»¥å…ˆç•¶æˆswitchçœ‹å¾…
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
```
# CH3 Common Programming Concepts

## Variables and Mutability

ç¸½ä¹‹å°±æ˜¯æœ‰`mut`ä»£è¡¨è®Šæ•¸ï¼Œæ²’æœ‰å‰‡ä»£è¡¨ä¸å¯è®Šï¼Œå¯ç”¨`const`ä¾†å®£å‘Šå¸¸æ•¸

### Shadowing

```rust=
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```

```
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x is: 12
```

* pass
```rust=
fn main() {
    let spaces = "   ";
 
    let spaces = spaces.len();
}
```
* error
```rust=
    let mut spaces = "   ";
    spaces = spaces.len();
```

## Data Types
Rustæ˜¯statically typed languageï¼Œä¹Ÿå°±æ˜¯èªªæ‰€æœ‰çš„è®Šæ•¸åœ¨compileæ™‚éƒ½å¾—æ±ºå®šå¥½å¥¹å€‘çš„å‹åˆ¥æ˜¯ç”šéº¼

* `let`æœƒå¹«ä½ æ¨å°è®Šæ•¸å‹åˆ¥
```rust=
fn main() {
    let a;
    let b = 1;
    a = 2;
}
```

### Scalar type
* æœ‰integers, floating-point numbers, Booleans, and characterså››ç¨®

#### int

![](https://i.imgur.com/9m29h2g.jpg)
![](https://i.imgur.com/wXmjmcl.jpg)

* rusté è¨­æ˜¯i32

#### float
```rust=
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```
#### bool
```rust=
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```

#### char

```rust=
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';
}
```
### Compound Types
è¤‡åˆå‹åˆ¥

#### Tuple


```rust=
fn main() {
    let tup = (500, 6.4, 1);
	
    let (x, y, z) = tup; //ç”¨letå®£å‘Šæ‰èƒ½é€™æ¨£åš
	
    println!("The value of y is: {}", y);
}
```

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
	
    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

#### Array

```rust=
let a: [i32; 5] = [1, 2, 3, 4, 5]; //i32 = type of each elements
let a = [3; 5]; // a = [3, 3, 3, 3, 3]
```

```rust=
fn main() {
    let a = [1, 2, 3, 4, 5];
    let first = a[0];
    let second = a[1];
}
```
## Function
Rustæ˜¯expression-based languageï¼Œå› æ­¤è¦ææ¸…æ¥šstatementè·Ÿexpressionçš„å·®åˆ¥ã€‚

å‡½å¼çµæ§‹æ¯”è¼ƒé¡ä¼¼PASCALã€‚
* expression
```rust=
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1 // æ²’æœ‰;
}
```
* statement
```rust=
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;// æœ‰;
}
```

## Comments
`//`

## Control Flow

### if else
```rust=
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```
### loop
```rust=
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```
### while 
```rust=
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```
### for
```rust=
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```

# CH4 Understanding Ownership
Ownershipæ˜¯Rustæœ€ç‰¹æ®Šçš„ç‰¹æ€§ï¼Œå®ƒæ­£æ˜¯åˆ©ç”¨ownershipä¾†å¯¦ç¾ä¸éœ€è¦åƒåœ¾å›æ”¶çš„è¨˜æ†¶é«”ç®¡ç†æ©Ÿåˆ¶ã€‚

é€™ç« æœƒè«‡ownershipè·Ÿä»–çš„ç›¸é—œç‰¹æ€§ï¼Œåƒæ˜¯borrowingè·Ÿslicesï¼Œé‚„æœ‰Rustçš„è¨˜æ†¶é«”ç®¡ç†æ–¹å¼ã€‚

## What Is Ownership?

å¸¸è¦‹çš„è¨˜æ†¶é«”ç®¡ç†æ–¹å¼æœ‰å…©ç¨®ï¼Œä¸€ç¨®æ˜¯æœ‰åƒåœ¾å›æ”¶æ©Ÿåˆ¶çš„èªè¨€ï¼Œå®ƒæœƒè‡ªå‹•å›æ”¶ä¸éœ€è¦çš„è¨˜æ†¶é«”ï¼Œå¦ä¸€ç¨®æ˜¯è¦æ˜ç¢ºåœ°å¯«å‡ºè¨˜æ†¶é«”çš„é…ç½®è·Ÿé‡‹æ”¾çš„èªè¨€ï¼Œè€ŒRustå±¬ç¬¬ä¸‰ç¨®

* é¦–å…ˆè¦è¤‡ç¿’ä¸€ä¸‹ï¼Œåœ¨è¨˜æ†¶é«”ç®¡ç†ä¸­
  * Stackç”¨ä¾†å­˜æ”¾å¯é æ¸¬å­˜æ´»é€±æœŸçš„è³‡æ–™ï¼ŒLIFOï¼Œstackå­˜æ”¾çš„æ±è¥¿å¯ç”±ç³»çµ±è‡ªè¡Œç”¢ç”Ÿèˆ‡å›æ”¶
  * è€Œheapç”¨ä¾†å­˜æ”¾ä¸å¯é æ¸¬å­˜æ´»é€±æœŸã€å‹•æ…‹ç”¢ç”Ÿå‡ºä¾†çš„è³‡æ–™ï¼Œå¦‚æœæ²’æœ‰é©ç•¶çš„é‡‹æ”¾æ‰æœƒé€ æˆmemory leakï¼Œæ‰€ä»¥æ‰æœƒæœ‰å¾ˆå¤šèªè¨€æä¾›åƒåœ¾å›æ”¶æ©Ÿåˆ¶ä¾†è‡ªå‹•è™•ç†æ‰é€™äº›æ²’æœ‰è¢«ä½¿ç”¨çš„è³‡æ–™ã€‚

Rustçš„è¨˜æ†¶é«”ç®¡ç†æ–¹å¼æ˜¯åˆ©ç”¨ownershipèˆ‡ä¸€ç³»åˆ—çš„è¦å‰‡(rule)ä¾†ç®¡ç†è¨˜æ†¶é«”ï¼Œè€Œé€™æœƒåœ¨compile timeæª¢æŸ¥

---
**Rule:**
1. Each value in Rust has a variable thatâ€™s called its owner.
2. There can only be one owner at a time.
3. When the owner goes out of scope, the value will be dropped.
---
åè©è§£é‡‹:
  * scope:è®Šæ•¸å­˜åœ¨çš„ç¯„åœ
```rust
fn main() {
    {                      // s is not valid here, itâ€™s not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
}

```
### String Type

`String` typeæ˜¯Rustæä¾›çš„ç¬¬äºŒç¨®stringç”¨æ³•ï¼Œé€™é‚Šæ›¸ç±ä»¥`String`ç‚ºä¾‹ä¾†è¨è«–ruleï¼Œch8æœƒè¨è«–æ›´æ·±çš„`String` typeç”¨æ³•

å‰ä¸€ç« æéçš„string literalsæœ‰å…©å€‹ç¼ºé»
1. immutable
2. not every string value can be known when we writing, ex: user input

* ç”±æ–¼ç¬¬äºŒå€‹ç¼ºé»è®“compile timeçš„æ™‚å€™æˆ‘å€‘ä¸¦ä¸çŸ¥é“è¦allocateå¤šå°‘è¨˜æ†¶é«”çµ¦å®ƒï¼Œä¹Ÿå› æ­¤å®ƒæ˜¯å­˜åœ¨heapä¸­
* ä½†æˆ‘å€‘ç¾åœ¨è¦ä½¿ç”¨çš„Stringæ˜¯å¯ä»¥é€éä¸‹åˆ—é€™ç¨®æ–¹å¼æ”¹è®Šçš„ï¼Œè€Œå¯ä»¥æ”¹è®Šçš„åŸå› å°±åœ¨æ–¼å…©è€…çš„è¨˜æ†¶é«”è™•ç†æ–¹å¼ä¸åŒ

```rust=
let mut s = String::from("hello"); 
// method in ch5
// namespacing with module in ch7

s.push_str(", world!"); // push_str() appends a literal to a String

println!("{}", s); // This will print `hello, world!`
```

### Memory and Allocation

`String` typeçš„ç›®æ¨™æœ‰å…©å€‹:
1. The memory must be requested from the memory allocator at runtime.
2. We need a way of returning this memory to the allocator when weâ€™re done with our `String`

* ç¬¬ä¸€å€‹ç›®æ¨™å‰›å‰›å·²ç¶“åˆ©ç”¨`String::from`é”æˆäº†ï¼Œé€™å€‹methodå°±æ˜¯åœ¨request Stringæ‰€éœ€è¦çš„memory

* ç¬¬äºŒå€‹ç›®æ¨™åœ¨å…¶ä»–èªè¨€ä¸­æœƒè¢«GCè™•ç†æ‰ï¼Œä½†åœ¨æ²’æœ‰GCçš„èªè¨€ä¸­ï¼Œæˆ‘å€‘éœ€è¦è‡ªå·±åˆ¤åˆ¥è¦é‡‹æ”¾é‚£äº›è¨˜æ†¶é«”ï¼Œe.g.:Allocate & free pair

* Rusté‡‹æ”¾è¨˜æ†¶é«”çš„æ™‚æ©Ÿå‰‡æ˜¯**ç•¶æ“æœ‰é€™å€‹è¨˜æ†¶é«”çš„owneré›¢é–‹äº†scopeçš„æ™‚å€™**

```rust=
{
	let s = String::from("hello"); // s is valid from this point forward

	// do stuff with s
}					// this scope is now over, and s is no longer valid
```
åœ¨é€™å€‹ä¾‹å­ä¸­ï¼Œså°±æ˜¯ownerï¼Œè€Œç•¶sé›¢é–‹äº†å®ƒçš„scopeï¼ŒRustå°±æœƒè‡ªå‹•callä¸€å€‹ç‰¹åˆ¥çš„å‡½å¼`drop()`ä¾†é‡‹æ”¾è¨˜æ†¶é«”ï¼Œrule 2å¯ä»¥ç¢ºä¿ä¸æœƒé‡‹æ”¾åˆ°å…¶ä»–æ±è¥¿

#### Ways Variables and Data Interact: Move

é€™é‚Šè¬›çš„æ˜¯`String`è·Ÿæ­£å¸¸è®Šæ•¸çœ‹å¾…è³‡æ–™è¤‡è£½çš„ä¸åŒä¹‹è™•

* æ­£å¸¸è®Šæ•¸çš„è™•ç†æ–¹å¼æœƒæ˜¯å„²å­˜å…©å€‹5ï¼Œowneråˆ†åˆ¥æ˜¯xå’Œyï¼Œè€Œä¸”æ˜¯æ”¾åœ¨stackä¸­
```rust=
let x = 5;
let y = x;
```

* `String`çš„è™•ç†æ–¹å¼å‰‡ä¸ä¸€æ¨£
```rust=
let s1 = String::from("hello");
let s2 = s1;
```

* `String`è£¡é¢æœ‰ptr, len, capacityï¼Œé€™äº›æ˜¯å­˜åœ¨stackä¸­ï¼Œä½†ptræŒ‡å‘çš„è³‡æ–™ï¼Œä¹Ÿå°±æ˜¯'hello'å‰‡æ˜¯å­˜åœ¨heapä¸­
![](https://doc.rust-lang.org/stable/book/img/trpl04-01.svg =400x400)

* åœ¨`assign` s1çµ¦s2æ™‚ï¼Œæ˜¯ç›´æ¥è¤‡è£½æ•´å€‹`String`ï¼Œè€Œéè¤‡è£½è³‡æ–™
![](https://doc.rust-lang.org/stable/book/img/trpl04-02.svg =400x400)

* ä½†é€™æ¨£å­˜å…¶å¯¦æœƒé€ æˆä¸€å€‹å•é¡Œï¼Œä¹Ÿå°±æ˜¯double free errorï¼Œåœ¨s1å’Œs2 out of scopeçš„æ™‚å€™ï¼Œéƒ½æœƒæƒ³`drop`åŒä¸€ç­†è³‡æ–™ï¼Œä½†å…©è€…çš„scopeå¯èƒ½ä¸¦ä¸ä¸€æ¨£

* ç•¶ç„¶ä½ å¯èƒ½æœƒæƒ³èªªï¼Œå¯ä»¥æ”¹æˆä¸‹åœ–é€™æ¨£ï¼Œä½†è‹¥é€™æ¨£ï¼Œheap dataå¾ˆå¤šçš„æ™‚å€™ï¼Œcostæœƒå¾ˆé«˜
![](https://doc.rust-lang.org/stable/book/img/trpl04-03.svg =500x500)

* è€ƒæ…®åˆ°é€™äº›å•é¡Œï¼Œå…¶å¯¦åœ¨è¤‡è£½`String`çš„æ™‚å€™ï¼ŒRuståšçš„ä¸¦ä¸æ˜¯è¤‡è£½ï¼Œè€Œæ˜¯**ç§»å‹•(Move)**ï¼ŒRuståœ¨`assign`s1çµ¦s2çš„æ™‚å€™å°±æœƒæŠŠs1è¨­ç‚º`invalid`ï¼Œä½†ä¸æœƒ`drop`æ‰è³‡æ–™ï¼Œå› æ­¤å¦‚æœåœ¨s2è¢«å‰µé€ ä¹‹å¾Œä½¿ç”¨s1çš„è©±æœƒè·‘éŒ¯
```rust=
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    println!("{}, world!", s1);
}
```
* æœƒæ‹¿åˆ°ä¸‹åˆ—çš„error message
![](https://i.imgur.com/orm5x6r.jpg)

* s1 invalidè€Œs2 validçš„ç¤ºæ„åœ–å¦‚ä¸‹
![](https://doc.rust-lang.org/stable/book/img/trpl04-04.svg =400x400)

#### clone

å‰›å‰›æåˆ°ç›´æ¥`assign`s1æœƒè®Šæˆæ˜¯åœ¨`Move`ï¼Œé‚£æ€æ¨£åšæ‰ä¸æœƒå‡ºç¾å•é¡Œå’§?

å› ç‚º`String`ä¸æ˜¯æœ‰`Copy`methodçš„ï¼Œå› æ­¤è¦åˆ©ç”¨`clone`ä¾†è¤‡è£½
```rust=
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```
* `Copy` traitæœƒåœ¨ch10è«‡æ›´æ·±ä¸€é»ï¼Œç¸½ä¹‹é€™é‚Šåªè¦çŸ¥é“`Copy`å’Œ`Move`ä¸åŒï¼Œç•¶`assign`çš„æ™‚å€™è¦çœ‹é‚£å€‹è³‡æ–™çµæ§‹æœ‰æ²’æœ‰`Copy`ï¼Œå¦‚æœæ²’æœ‰çš„è©±å°±æœƒè®Šæˆæ˜¯åœ¨`Move`

* åŸºæœ¬è³‡æ–™å‹æ…‹å…¨éƒ¨éƒ½æœ‰å¯¦ä½œ`Copy`ï¼Œåƒæ˜¯int, float, bool, char, Tuple

### Ownership and Functions

å‘¼å«å‡½å¼çš„æ™‚å€™å‚³éåƒæ•¸çš„æ–¹å¼å’Œå‰›å‰›èªªçš„ä¸€æ¨£ï¼Œæœ‰`Copy`å°±æœƒç”¨`Copy`ï¼Œæ²’æœ‰å°±æœƒè®Šæˆ`Move`

```rust=
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so itâ€™s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```
* å¦‚æœåœ¨call `takes_ownership`ä¹‹å¾Œä½¿ç”¨`s`å°±æœƒå‡ºéŒ¯

### Return Values and Scope

ä½ å¯ä»¥å†å‚³å›ä¾†é˜¿

WTF ???
![](https://i.imgur.com/Fm0wUdA.jpg)


```rust=
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {        // gives_ownership will move its
                                        // return value into the function
                                        // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```
çœ‹ä¾†ä½œè€…å¾ˆå¹½é»˜ã„›

* ä¹Ÿå¯ä»¥ç”¨tupleæŠŠå®ƒå‚³å›ä¾†ï¼Œç­‰ç­‰æœƒç”¨åˆ°é€™å€‹ä¾‹å­
```rust=
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```

é‚£éº¼ï¼Œwhat should we doå‘¢?
ç­”æ¡ˆå°±åœ¨ä¸‹ä¸€ç¯€
## References and Borrowing

* å…¶å¯¦åªè¦æŠŠå‚³å…¥çš„åƒæ•¸æ”¹ç‚ºreference(`&`)å°±å¥½äº†
* åƒè€ƒå°±è·Ÿownershipç„¡é—œäº†ï¼Œ`&s1`ä¸¦æ²’æœ‰æ“æœ‰`s1`çš„å€¼ï¼Œè€Œåªæ˜¯å‰µé€ ä¸€å€‹æŒ‡å‘`s1`è¨˜æ†¶é«”ä½ç½®çš„åƒè€ƒï¼Œç•¶ç„¶ä¹Ÿä¸éœ€è¦å›å‚³ï¼Œå› ç‚ºå®ƒæ ¹æœ¬æ²’æœ‰ownership
* é †å¸¶ä¸€æåƒè€ƒçš„scopeæ˜¯å¾è¢«å¼•å…¥é–‹å§‹ç›´åˆ°æœ€å¾Œä¸€æ¬¡è¢«ä½¿ç”¨
```rust=
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, nothing happens.
```
* ç¬¬10è¡Œçš„sä¸éœ€è¦dereferencing(`*`)æ˜¯å› ç‚ºRustæœƒè‡ªå‹•å¹«ä½ è§£ï¼Œä¸ç„¶ç†è«–ä¸Šæ˜¯è¦å¯«æˆ`(*s).len()`
* referenceç¤ºæ„åœ–
![](https://doc.rust-lang.org/stable/book/img/trpl04-05.svg =500x500)

* Rustä¸­å°‡é€™ç¨®åˆ©ç”¨referenceå‚³éå‡½æ•¸åƒæ•¸çš„æ–¹æ³•ç¨±ç‚º**borrowing** 

* é‚£å¦‚æœæˆ‘å€‘ä¿®æ”¹borrowingä¸­çš„åƒæ•¸æœƒæ€æ¨£å’§

```rust=
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```
é€™æœƒå¾—åˆ°ä¸‹åœ–çš„error message
![](https://i.imgur.com/ckPdBPP.jpg)
* é€™æ˜¯å› ç‚ºå®£å‘Šè®Šæ•¸çš„æ™‚å€™å®ƒé è¨­æ˜¯immutableï¼Œæ‰€ä»¥ä»–çš„åƒè€ƒä¹Ÿæ˜¯immutableçš„
* è¦è§£æ±ºç•¶ç„¶å°±æ˜¯æŠŠå®ƒå®£å‘Šæˆmutableå°±å¥½
```rust=
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

* ä½†æ˜¯mutable referenceæœ‰ä¸€å€‹å¾ˆå¤§çš„é™åˆ¶å°±æ˜¯ä¸€å€‹scopeä¸­åªèƒ½æœ‰ä¸€å€‹mutable referenceï¼Œé€™æ˜¯ç‚ºäº†ç¶­æŒå®‰å…¨æ€§ï¼Œé¿å…**data races**

* **data races**å°±é¡ä¼¼race conditionï¼Œåœ¨ä»¥ä¸‹æƒ…æ³æœƒç™¼ç”Ÿ
  * Two or more pointers access the same data at the same time.
  * At least one of the pointers is being used to write to the data.
  * Thereâ€™s no mechanism being used to synchronize access to the data.

* åªè¦æœ‰é€™æ¨£çš„æƒ…æ³ç™¼ç”Ÿï¼Œcompileå°±ä¸æœƒéï¼ŒRustçš„ç²¾ç¥å°±æ˜¯å¯§é¡˜compileå¾ˆåš´æ ¼ä¹Ÿä¸è¦ä¸å®‰å…¨ï¼Œå¦‚ä¸‹ä¾‹å°±ä¸æœƒé
```rust=
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);
```
* error message
![](https://i.imgur.com/vbWAZ5n.jpg)

* ç•¶ç„¶å…¶å¯¦åªè¦è®“ä»–å€‘å…©å€‹ä¸åœ¨åŒä¸€å€‹scopeå°±è¡Œå•¦
```rust=
let mut s = String::from("hello");
{
    let r1 = &mut s;
} // r1 goes out of scope here, so we can make a new reference with no problems.

let r2 = &mut s;
```

* ä¹Ÿå¯ä»¥å–„ç”¨reference scopeçš„ç‰¹æ€§ä¾†åˆ†é–‹
```rust=
let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
println!("{} and {}", r1, r2);
// r1 and r2 are no longer used after this point

let r3 = &mut s; // no problem
println!("{}", r3);
```

### Dangling References

dangling pointeræŒ‡çš„æ˜¯æŒ‡æ¨™æŒ‡åˆ°äº†å·²ç¶“è¢«åˆ†é…çµ¦å…¶ä»–äººçš„è¨˜æ†¶é«”ä½å€æˆ–è€…æ˜¯å·²ç¶“è¢«é‡‹æ”¾çš„ä½å€çš„å•é¡Œï¼Œä½†Rustä¸­ä¸æœƒç™¼ç”Ÿé€™ç¨®æƒ…æ³

* sçš„scopeæ˜¯åœ¨dangle()ä¸­çš„ï¼ŒdangleçµæŸçš„æ™‚å€™å®ƒå°±è¢«é‡‹æ”¾äº†ï¼Œä½†æ˜¯é€™é‚Šå»æƒ³returné€™å€‹sçš„åƒè€ƒå‡ºä¾†
```rust=
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
```
* error message
![](https://i.imgur.com/BykQ7Tr.jpg)
é€™é‚Šæœ‰æåˆ°lifetimeï¼Œch10æœƒè¬›åˆ°ï¼Œé€™é‚Šå…ˆä¸æ

* æ²’å•é¡Œçš„code
```rust=
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```

## Slice Type
Sliceæ˜¯å¦ä¸€å€‹æ²’æœ‰ownershipçš„data typeï¼Œslicesè®“ä½ åƒè€ƒä¸€å€‹é€£çºŒçš„ç©ºé–“

* Format: &åç¨±[start..end]
```rust=
let s = String::from("hello world");

let hello = &s[0..5];  //ç­‰åŒæ–¼&s[..5];
let world = &s[6..11]; //ç­‰åŒæ–¼&s[6..];
let h = s[0];          //é€™æ¨£ç”¨æœƒerror
```
* åœ–
![](https://doc.rust-lang.org/stable/book/img/trpl04-06.svg =500x500)

### String literals are slices
* sçš„typeæ˜¯`&str`ï¼Œé€™ä¹Ÿæ˜¯string literalsæ˜¯immutableçš„åŸå› ï¼Œå› ç‚ºstringæœ¬ä¾†å°±immutableï¼Œè€Œå®ƒåªæ˜¯stringçš„åƒè€ƒ
```rust=
let s = "Hello, world!";
```

### Array slices
sliceçš„typeæ˜¯`&[]`ï¼Œä¹Ÿå¯ç”¨æ­¤æ€§è³ªåƒè€ƒæœªçŸ¥å¤§å°çš„array
```rust=
fn main() {
    let a = [1, 2, 3, 4, 5]; // [i32; 5]
    let slice_1 = &a[1..3]; // &[i32]
    let slice_2 = &a; // &[i32; 5]
 
    println!("{:?}", a);
    println!("{:?}", slice_1);
    println!("{:?}", slice_2);
}
```

## Q&A

* ä»€éº¼æ™‚å€™æ‰éœ€è¦è‡ªå·±è§£åƒè€ƒ
